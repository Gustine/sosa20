<?php
/*
 * …/modules_v4/sosa20/resources/views/update.phtml
 * help : https://gustine.eu/mode_emploi/sosa.php
 * MR 2022-05 registry::individualFactory()->make() instead of deprecated Individual::getInstance().
 * MR 2022-09 error indi_root not found
 * MR 2023-06 simplified fill_sosa_table function.
 * MR 2025-05 the memory used by the update is limited to avoid overflows and the calculation is stopped when all the Sosa numbers have been found.
 * MR 2025-06 new algorithm: browse the wt_sosa table instead of testing all possible Sosa numbers
 * MR 2025-06 bug line 129 : ($gen+1)
 * MR 2025-10 if img/image.png is present, display the user's Sosa numbers (requires adding a column to the wt_sosa table)
 * RickM 2025-11 improved wording of messages in English.
 */
use Fisharebest\Webtrees\Auth;
use Fisharebest\Webtrees\Functions\FunctionsPrint; 
use Fisharebest\Webtrees\I18N; 
use Fisharebest\Webtrees\Individual;
use Fisharebest\Webtrees\Registry;
use Fisharebest\Webtrees\Site;
use Fisharebest\Webtrees\Tree;
use Fisharebest\Webtrees\View;
use Illuminate\Database\Capsule\Manager as DB;
use Illuminate\Database\Schema\Blueprint;

echo '<div class="wt-main-wrapper">' ;
	echo '<table class="table wt-facts-table">';
	echo '<tr><td><h3>' . I18N::translate('Updating Sosa numbers') . ' :</h3>';
	if ($tree === null) {
		echo '<span style="color: red">Error</span> (tree === null)'; 
		}
	else {
		$individual = Registry::individualFactory()->make($bk_xref, $tree);
		$indi_root = Registry::individualFactory()->make($up_xref, $tree);
		if ($indi_root === null) echo '⁂  indi_root not found';
		else echo '<p>' . I18N::translate('Family tree #') . $up_gid . ' ' . I18N::translate('using %s as Sosa 1', $indi_root->FullName()) . '.</p>';
		if (Auth::isMember($tree)) {
			delete_all_sosas($up_gid, $user_id); /* we empty the sosas table corresponding to $up_gid */
			$tree_array = fill_sosa_table($up_gid, $up_xref, $tree, $user_id); /* then we fill it again */
			}
		else {
			echo '<p>⁂ ' . I18N::translate('You need member rights, or higher, to do this.') . '</p>';
			}

		echo '</td></tr><tr><td>';
		echo '<h3>' . I18N::translate('Return to the previous page') . ' :</h3>';
		echo '<a href="' . $individual->url() . '">' . $individual->FullName() . '</a>';
		}
	echo '</td></tr></table>';
echo '</div>';

/* = = = = = = = = = = = = = = = =
 * Returns root xref for a given gedcom.
 */
function find_root_xref($sosa_gid)
{
	$root_xref = DB::table('sosa')
	->where('sosa_num', '=', 1)
	->where('sosa_gid', '=', $sosa_gid)
	->value('sosa_xref') ;
	return $root_xref; 
}

/* = = = = = = = = = = = = = = = =
 * Fills the sosas table of the tree whose identifier is $sosa_gid.
 * Number 1 is the root individual whose xref is $sosa_root_xref. 
 * The others are filled in the following way, until the $maxgen generation,
 * if an individual has the number i then his father is number i*2 and his mother is number i*2+1.
 */

/* Remplit la table des sosas de l’arbre d’indice $sosa_gid.
 * Le numéro 1 est la personne racine dont la xref est $sosa_root_xref. 
 * Les autres sont remplis de la façon suivante, jusqu’à la génération $maxgen,
 * si un individu porte le numéro i alors son père est numéro i*2 et sa mère est numéro i*2+1.

 * Le principe de calcul : une génération après l’autre, on parcourt la table Sosa et on recherche si l’individu a un père.
 * S’il existe on inscrit son numéro Sosa (génération n+1) dans la table. Même chose pour sa mère.
 * Si le traitement de la génération en cours s’achève sans qu’on ne trouve ni père ni père, inutile d'aller plus loin car tous les numéros Sosa ont été trouvés.

 * En mode « test » on peut afficher ce cheminement. Pour cela, dans le fichier update.html, 
 * il faut mettre en commentaire "display: none" ligne 107 et donner une valeur pertinente à "$test" ligne 108.
 */
function fill_sosa_table($sosa_gid, $sosa_root_xref, $tree, $user_id)
{
	$maxgen = 40;
	/* The wt_sosa table created by older versions involves sosa_num < 2^31, i.e. max_gen = 31.
	 * This limit was raised to 2^63 in June 2025. To update, delete the wt_sosa table using phpmyadmin.
	 * It will be recreated with the correct parameters (ignore any error message, reload the page and continue).
	 * To process all the generations, you may need to increase memory_limit in php.d/01_ressourcelimits on the server.
	 */

	/* La table wt_sosa créée par les anciennes versions implique sosa_num < 2^31 soit max_gen = 31.
	 * Cette limite a été portée à 2^63 en juin 2025. Pour mettre à jour, effacer la table wt_sosa avec phpmyadmin.
	 * Elle sera recréée avec les bons paramètres (ignorer l'éventuel message d'erreur, recharger la page et continuer).
	 * Pour traiter toutes les générations, il faudra peut-être augmenter memory_limit dans php.d/01_ressourcelimits sur le serveur.
	 */
	$memory_limit = ini_get('memory_limit'); // set in php.d/ressourcelimits.ini
	$memory_val = trim($memory_limit);
	$memory_last = strtolower($memory_val[strlen($memory_val)-1]);
	$memory_val = substr($memory_val, 0, -1);
	switch($memory_last) {
		case 'g': $memory_val *= 1024;
		case 'm': $memory_val *= 1024;
		case 'k': $memory_val *= 1024;
		}
	$memory_secure = 0.75 * $memory_val; // safety margin to prevent memory overflow

	echo '<style> .test { color: darkgreen;  display: none;} </style>'; // test
	$test = 40; // generation from which test information is displayed
	$time_start = microtime(true);
	$tree_array = array();
	$L2 = log10(2);
	$tree_array[0] = "";

	// -- fill in first generation
	$tree_array[1] = $sosa_root_xref;
	$sosa_num = 1; $top_sosa = 1;
	$sosa_gen = 1;
	insert_sosa_table($tree_array[1], $sosa_gid, $sosa_num, $sosa_gen, $user_id);

	// -- fill in other generations
	$stop = false; // will stop the calculation when all sosas have been found

	$begin = find_sosa_id($sosa_gid, $sosa_num, $user_id); // $sosa_num = 1
	$last_id = $begin;
	$end = $begin+1;
	for ($gen = 1; ($gen < $maxgen) && ($stop === false); $gen++) {
		if ($gen >= $test) // test
			echo '<span class="test"><br> * gen = ' . $gen
				. ' (id = ' . I18N::number($begin) . '/' . I18N::number($end-1) . ')' . ' | parents’sosa (gen ' . ($gen+1) . ') = ' 
				. '</span>';
		$stop = true; // stop at the next iteration if no family is found (no need to go any further)
		$full_gen = $gen; // $gen -1 is the last generation whose parents have all been treated (the $gen generation is therefore complete)
		// New algorithm: browse the wt_sosa table instead of testing all possible Sosa numbers. 
		for ($id = $begin; ($id < $end) && (memory_get_peak_usage($real_usage = true) < $memory_secure); $id++) {
			$num = find_sosa_num_from_id($id, $user_id);
			$tree_array[$num * 2] = false; // father is presumed empty until proven otherwise
			$tree_array[$num * 2 + 1] = false; // mother…
			if (empty($tree_array[$num])) echo '<p>⁂ Error $num = ' . $num . '</p>'; 
			else {
				$person = Registry::individualFactory()->make($tree_array[$num], $tree);
				$family = $person->childFamilies()->first();
				if ($family) {
					$stop = false;
					if ($family->Husband()) {
						$sosa_num = $num * 2;
						$tree_array[$sosa_num] = $family->Husband()->Xref();
						$sosa_gen = log10($sosa_num) / $L2;
						$sosa_gen = (int)$sosa_gen + 1;
						insert_sosa_table($tree_array[$sosa_num], $sosa_gid, $sosa_num, $sosa_gen, $user_id);
						$last_id = find_sosa_id($sosa_gid, $sosa_num, $user_id);
						if ($gen >= $test) {
							$person = Registry::individualFactory()->make($tree_array[$sosa_num], $tree);
							echo '<span class="test"><a href="' . $person->url() . '">' . I18N::number($sosa_num) . '</a>, </span>';
							}
						if ($sosa_num > $top_sosa) $top_sosa = $sosa_num;
						}
					if ($family->Wife()) {
						$sosa_num = $num * 2 + 1;
						$tree_array[$sosa_num] = $family->Wife()->Xref();
						$sosa_gen = log10($sosa_num) / $L2;
						$sosa_gen = (int)$sosa_gen + 1;
						insert_sosa_table($tree_array[$sosa_num], $sosa_gid, $sosa_num, $sosa_gen, $user_id);
						$last_id = find_sosa_id($sosa_gid, $sosa_num, $user_id);
						if ($gen >= $test) {
							$person = Registry::individualFactory()->make($tree_array[$sosa_num], $tree);
							echo '<span class="test"><a href="' . $person->url() . '">' . I18N::number($sosa_num) . '</a>, </span>';
							}
						if ($sosa_num > $top_sosa) $top_sosa = $sosa_num;
						}
					}
				} //else !empty
			} // for $id
		$begin = $end;
		$end = $last_id+1;
		} // for $gen
	$top_gen = round (log10($top_sosa) / $L2 + 0.5); // maximum generation for which a sosa has been found
	if ($end === $begin) $full_gen++; // the for $gen instruction has been interrupted by the $stop condition, the generation calculation is complete, so $full_gen++
	$time_end = microtime(true);

	$memory_peak = memory_get_peak_usage($real_usage = true);
	if (($full_gen > $top_gen) && ($memory_peak < $memory_secure)) $OK = true;	// we looked for - but didn't find - all the parents of the top+1 generation
	else $OK = false;

	echo ' <p>';
	if ($OK) echo '<b>' . I18N::translate('OK') . '.</b> ';
	echo '<b>' . I18N::translate('The Sosa table is complete to generation %s.', $top_gen) . '</b>';
	$top_person = Registry::individualFactory()->make($tree_array[$top_sosa], $tree);
	echo '<br><abbr title="' . I18N::translate('Highest Sosa number found. In the case of a pedigree collapse, common ancestors have several numbers, only the the lowest is displayed in the sidebar.') .'">(sosa</abbr> '
	. I18N::number($top_sosa) . ' : <a href="' . $top_person->url() . '"> ' . $top_person->FullName() . '</a>)';
	if (!$OK) echo '<br>' . I18N::translate('But all parents may not have been found!') . ' ';
	else {
		echo '<br>' . I18N::translate('We checked and there is no parent at generation %s', $full_gen);
		if ($gen - $top_gen > 1) echo ' ' . I18N::translate('(pedigree collapse)') . '.'; else echo '.';
		}
	echo '</p>';

	echo '<p>';
	echo '<abbr title="' . I18N::translate('Maximum number of generations for which Sosa numbers will be searched. Defined in resources/views/update.phtml of the sosa20 module. If too low, Sosa numbers may be missing.')
	. '">maxgen</abbr> = ' . $maxgen;
	if ($OK && ($maxgen - $top_gen > 2))
		echo '. ' . I18N::translate('Calculation stopped at generation %s', $gen) . I18N::translate(' (there was no parent found therefore no Sosa numbers to calculate).');
	if (!$OK && ($maxgen - $top_gen < 1)) echo ' ' . I18N::translate('The maxgen parameter should be increased to ensure that all the Sosa numbers have been calculated.') . ' ';

	echo '<br><abbr title="' . I18N::translate('Maximum memory allocated to php. Set in php.d/01_ressourcelimits on the server (apache).') . '">memory limit</abbr> = ' .  $memory_limit . ' ⇨ ' . I18N::translate(' %s&#37 used', I18N::number($memory_peak/$memory_val * 100, $precision = 1)) . '. ';
	if ($memory_peak >= $memory_secure) echo I18N::translate('The calculation was stopped to prevent a possible php ’memory overflow’ error.');
	echo '<br>' . I18N::translate('Elapsed time') .' = ' . round (($time_end-$time_start) * 1000, $precision = 1) . ' ms.</p>';

	return $tree_array;
}

/* = = = = = = = = = = = = = = = =
 * Deletes all the sosas of the table, for given gedcom and user.
 */
function delete_all_sosas($sosa_gid, $user_id)
{
	DB::table('sosa')
		->where('sosa_gid', '=', $sosa_gid)
		->where('user_id', '=', $user_id)
		->delete();
}

/* = = = = = = = = = = = = = = = =
 * Inserts the data of an individual in the table of sosas.
 */
function insert_sosa_table($sosa_xref, $sosa_gid, $sosa_num, $sosa_gen, $user_id)
{
	DB::table('sosa')->insert([
		'sosa_xref' => $sosa_xref,
		'sosa_gid' => $sosa_gid,
		'sosa_num' => $sosa_num,
		'sosa_gen' => $sosa_gen,
		'user_id' => $user_id,
	]);
}

/* = = = = = = = = = = = = = = = =
 * Find sosa_id for given gedcom, number and user.
 */
function find_sosa_id($sosa_gid, $sosa_num, $user_id)
{
	$sosa_id = DB::table('sosa')
	->where('sosa_num', '=', $sosa_num)
	->where('sosa_gid', '=', $sosa_gid)
	->where('user_id', '=', $user_id)
	->value('sosa_id') ;
	return $sosa_id;
}

/* = = = = = = = = = = = = = = = =
 * Find sosa_num for a given user.
 */
function find_sosa_num_from_id($sosa_id, $user_id)
{
	$sosa_num = DB::table('sosa')
	->where('sosa_id', '=', $sosa_id)
	->where('user_id', '=', $user_id)
	->value('sosa_num') ;
	return $sosa_num;
}
